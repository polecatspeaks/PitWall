# Pit Wall - Test-Driven Development Roadmap

## Quick Reference for Python → C# Developers

### Key Differences
- **Testing**: xUnit/NUnit instead of pytest
- **Mocking**: Moq library instead of unittest.mock
- **DI**: Constructor injection is standard (no decorators)
- **Async**: async/await similar but Task<T> instead of coroutines
- **Types**: Explicit interfaces and strongly typed (no duck typing)

### VS Code + Copilot TDD Workflow
1. Write test first (describe what you want in comments)
2. Let Copilot suggest implementation (Tab to accept)
3. Run test: `dotnet test` (Red)
4. Write minimal code to pass (Green)
5. Refactor with Copilot's suggestions (Refactor)

### Useful Commands
```bash
# Create new test project
dotnet new xunit -n PitWall.Tests

# Run tests with detailed output
dotnet test --logger "console;verbosity=detailed"

# Run tests with coverage
dotnet test /p:CollectCoverage=true

# Watch mode (re-run on file changes)
dotnet watch test
```

---

## Phase 0: Development Environment & Scaffolding

### Goal
Establish a working development environment with CI/CD, plugin skeleton, and ability to mock SimHub for testing.

### Acceptance Criteria
- [ ] Solution builds successfully in VS Code
- [ ] Unit tests run and pass (even if trivial)
- [ ] Plugin DLL loads in SimHub without crashing
- [ ] GitHub Actions CI runs tests on every push
- [ ] Mock SimHub data provider works for testing
- [ ] Performance benchmark baseline established (<1% CPU idle)

### Tests to Write First

#### 1. Plugin Lifecycle Tests
```csharp
// PitWall.Tests/PluginLifecycleTests.cs
public class PluginLifecycleTests
{
    [Fact]
    public void Plugin_Initializes_WithoutCrashing()
    {
        // Arrange
        var mockPluginManager = new Mock<IPluginManager>();

        // Act
        var plugin = new PitWallPlugin();
        plugin.Init(mockPluginManager.Object);

        // Assert
        Assert.NotNull(plugin);
        Assert.Equal("Pit Wall Race Engineer", plugin.Name);
    }

    [Fact]
    public void Plugin_End_CleansUpResources()
    {
        // Arrange
        var plugin = new PitWallPlugin();
        plugin.Init(new Mock<IPluginManager>().Object);

        // Act & Assert (should not throw)
        plugin.End(new Mock<IPluginManager>().Object);
    }
}
```

#### 2. Performance Baseline Tests
```csharp
// PitWall.Tests/PerformanceTests.cs
public class PerformanceTests
{
    [Fact]
    public void Plugin_DataUpdate_CompletesWithin10ms()
    {
        // This ensures <5% CPU at 100Hz update rate
        var plugin = new PitWallPlugin();
        var mockManager = CreateMockPluginManager();
        plugin.Init(mockManager);

        var stopwatch = Stopwatch.StartNew();
        plugin.DataUpdate(mockManager, CreateMockData());
        stopwatch.Stop();

        Assert.True(stopwatch.ElapsedMilliseconds < 10);
    }
}
```

#### 3. Mock Data Provider Tests
```csharp
// PitWall.Tests/Mocks/MockTelemetryTests.cs
public class MockTelemetryTests
{
    [Fact]
    public void MockTelemetry_ProvidesValidGT3Data()
    {
        var telemetry = MockTelemetryBuilder.GT3()
            .WithLapTime(TimeSpan.FromSeconds(120))
            .WithFuelLevel(50.0)
            .Build();

        Assert.Equal(120.0, telemetry.LapTime, 0.1);
        Assert.InRange(telemetry.FuelLevel, 0, 100);
    }
}
```

### Core Components

```
PitWall/
├── PitWall.csproj              # Main plugin project
├── PluginManifest.json         # SimHub plugin metadata
├── PitWallPlugin.cs            # Entry point (IPlugin interface)
└── Core/
    ├── ITelemetryProvider.cs   # Interface for telemetry data
    └── IStrategyEngine.cs      # Interface for strategy logic

PitWall.Tests/
├── PitWall.Tests.csproj
├── PluginLifecycleTests.cs
├── PerformanceTests.cs
└── Mocks/
    ├── MockPluginManager.cs
    ├── MockTelemetryBuilder.cs
    └── MockTelemetryTests.cs

.github/
└── workflows/
    └── ci.yml                  # GitHub Actions for CI
```

### SimHub Integration Points

1. **IPlugin Interface** (mandatory)
   - `Init(PluginManager)` - Called once on plugin load
   - `End(PluginManager)` - Cleanup on unload
   - `DataUpdate(PluginManager, PluginData)` - Called ~100Hz

2. **PluginManager Properties to Read**
   - `GetPropertyValue("DataCorePlugin.GameRunning")` - Is sim running?
   - `GetPropertyValue("DataCorePlugin.GameData.Fuel")` - Current fuel
   - `GetPropertyValue("DataCorePlugin.GameData.LapTime")` - Lap time
   - `GameName` - Which simulator (iRacing, ACC, etc.)

3. **Plugin Settings**
   - Use `AddProperty("SettingName", defaultValue)` for user config
   - Settings UI auto-generated by SimHub

### Success Metrics

- ✅ `dotnet build` succeeds with zero warnings
- ✅ `dotnet test` runs in <2 seconds with 100% pass rate
- ✅ Plugin loads in SimHub (check Installed Plugins tab)
- ✅ GitHub Actions badge shows passing
- ✅ CPU usage <1% when idle (Task Manager verification)

### Estimated Effort
**3-5 days** (includes learning curve for C# tooling)

- Day 1: Project setup, VS Code configuration, CI/CD
- Day 2: SimHub SDK integration, plugin skeleton
- Day 3: Mock framework, first passing tests
- Day 4-5: Documentation, troubleshooting SimHub quirks

### Dependencies
- .NET SDK 8.0 installed
- SimHub 9.x installed (for manual testing)
- SimHub Plugin SDK DLLs (copy from SimHub install dir)
- VS Code extensions: C# Dev Kit, GitHub Copilot

### Resources
- [SimHub Plugin Documentation](https://github.com/SHWotever/SimHub/wiki/Plugin-development)
- [xUnit Docs](https://xunit.net/)
- [Moq Quickstart](https://github.com/moq/moq4/wiki/Quickstart)

---

## Phase 1: Basic Telemetry → Strategy Logic (Proof of Concept)

### Goal
Build the simplest possible "race engineer brain" that can recommend a pit stop based on fuel consumption. Prove the core data flow works.

### Acceptance Criteria
- [ ] Reads fuel level and lap times from telemetry
- [ ] Calculates fuel usage per lap
- [ ] Predicts laps remaining before empty tank
- [ ] Generates "Box this lap" message when <2 laps fuel remaining
- [ ] Strategy updates every lap (not every tick)
- [ ] All logic covered by unit tests (>80% coverage)

### Tests to Write First

#### 1. Fuel Usage Tracking Tests
```csharp
// PitWall.Tests/Strategy/FuelStrategyTests.cs
public class FuelStrategyTests
{
    [Theory]
    [InlineData(100.0, 95.0, 5.0)]  // Start: 100L, End: 95L, Used: 5L
    [InlineData(50.0, 48.3, 1.7)]
    public void CalculateFuelUsedPerLap_ReturnsCorrectValue(
        double startFuel, double endFuel, double expected)
    {
        var strategy = new FuelStrategy();
        var result = strategy.CalculateFuelUsed(startFuel, endFuel);
        Assert.Equal(expected, result, 0.01);
    }

    [Fact]
    public void PredictLapsRemaining_WithConstantUsage_ReturnsAccuratePrediction()
    {
        var strategy = new FuelStrategy();
        strategy.RecordLap(fuelUsed: 5.0);
        strategy.RecordLap(fuelUsed: 5.2);
        strategy.RecordLap(fuelUsed: 4.8);

        var remaining = strategy.PredictLapsRemaining(currentFuel: 25.0);

        Assert.InRange(remaining, 4.5, 5.5); // ~25L / 5L per lap
    }
}
```

#### 2. Pit Stop Recommendation Tests
```csharp
public class PitStopRecommendationTests
{
    [Fact]
    public void ShouldBoxThisLap_WhenFuelLessThan2Laps_ReturnsTrue()
    {
        var engine = new StrategyEngine();
        var telemetry = MockTelemetryBuilder.GT3()
            .WithFuelRemaining(9.0)          // 9L remaining
            .WithAverageFuelPerLap(5.0)      // 5L per lap
            .Build();

        var recommendation = engine.GetRecommendation(telemetry);

        Assert.True(recommendation.ShouldPit);
        Assert.Equal("Box this lap - fuel critical", recommendation.Message);
    }

    [Fact]
    public void ShouldBoxThisLap_WhenPlentifulFuel_ReturnsFalse()
    {
        var engine = new StrategyEngine();
        var telemetry = MockTelemetryBuilder.GT3()
            .WithFuelRemaining(50.0)
            .WithAverageFuelPerLap(5.0)      // 10 laps remaining
            .Build();

        var recommendation = engine.GetRecommendation(telemetry);

        Assert.False(recommendation.ShouldPit);
    }
}
```

#### 3. Telemetry Provider Tests
```csharp
public class SimHubTelemetryProviderTests
{
    [Fact]
    public void GetCurrentTelemetry_ReadsSimHubProperties()
    {
        var mockManager = new Mock<IPluginManager>();
        mockManager.Setup(m => m.GetPropertyValue("DataCorePlugin.GameData.Fuel"))
            .Returns(45.5);
        mockManager.Setup(m => m.GetPropertyValue("DataCorePlugin.GameData.LastLapTime"))
            .Returns(122.345);

        var provider = new SimHubTelemetryProvider(mockManager.Object);
        var telemetry = provider.GetCurrentTelemetry();

        Assert.Equal(45.5, telemetry.FuelRemaining);
        Assert.Equal(122.345, telemetry.LastLapTime);
    }
}
```

### Core Components

```csharp
// PitWall/Strategy/FuelStrategy.cs
public class FuelStrategy
{
    private readonly List<double> _fuelUsageHistory = new();

    public void RecordLap(double fuelUsed);
    public double GetAverageFuelPerLap();
    public double PredictLapsRemaining(double currentFuel);
}

// PitWall/Strategy/StrategyEngine.cs
public class StrategyEngine
{
    private readonly FuelStrategy _fuelStrategy;

    public Recommendation GetRecommendation(Telemetry telemetry);
}

// PitWall/Models/Telemetry.cs
public class Telemetry
{
    public double FuelRemaining { get; set; }
    public double LastLapTime { get; set; }
    public int CurrentLap { get; set; }
    public bool IsInPit { get; set; }
}

// PitWall/Models/Recommendation.cs
public class Recommendation
{
    public bool ShouldPit { get; set; }
    public string Message { get; set; }
    public RecommendationType Type { get; set; } // Fuel, Tyres, etc.
}
```

### SimHub Integration Points

1. **Properties to Read**
   ```csharp
   // Fuel data
   "DataCorePlugin.GameData.Fuel"              // Current fuel (liters or %)
   "DataCorePlugin.GameData.FuelCapacity"      // Max tank capacity

   // Lap timing
   "DataCorePlugin.GameData.CurrentLap"        // Current lap number
   "DataCorePlugin.GameData.LastLapTime"       // Last lap in seconds
   "DataCorePlugin.GameData.IsInPitLane"       // In pit? (bool)
   ```

2. **Update Strategy**
   - Don't process every `DataUpdate()` call (too frequent)
   - Use lap crossing detection: `if (telemetry.CurrentLap != _lastLap)`
   - Store previous lap fuel to calculate delta

### Success Metrics

- ✅ Unit tests for fuel calculation: >90% coverage
- ✅ Strategy engine recommends pit stop accurately in test scenarios
- ✅ Mock telemetry builder supports realistic race scenarios
- ✅ Plugin logs recommendation to SimHub logs (visible in debug mode)
- ✅ Performance: Strategy update <5ms per lap

### Estimated Effort
**5-7 days**

- Day 1: Telemetry models and provider interface
- Day 2: Fuel tracking logic (TDD)
- Day 3: Strategy engine core logic
- Day 4: SimHub integration and lap detection
- Day 5-6: Edge cases, testing with real SimHub data
- Day 7: Refactoring and documentation

### Dependencies
- Phase 0 complete (plugin skeleton working)
- Access to SimHub with a running sim (or replay file)

### Validation Checklist
- [ ] Run tests: `dotnet test --logger "console;verbosity=detailed"`
- [ ] Load plugin in SimHub
- [ ] Start a race replay in ACC/iRacing
- [ ] Check SimHub logs for "Box this lap" message when fuel low
- [ ] Verify CPU usage <2% during race

---

## Phase 2: Audio Playback & Message Queueing

### Goal
Replace text logs with audio messages. Build a queue system that prevents message spam (e.g., don't repeat "Box now!" every 100ms).

### Acceptance Criteria
- [ ] Plays audio samples (.wav files) through SimHub's audio system
- [ ] Message queue prevents duplicates within configurable time window
- [ ] Priority system (Critical > Warning > Info)
- [ ] Messages don't interrupt each other (wait for completion)
- [ ] Volume control through SimHub settings UI
- [ ] Audio playback tested without actual sound hardware (mock)

### Tests to Write First

#### 1. Audio Playback Tests
```csharp
// PitWall.Tests/Audio/AudioPlayerTests.cs
public class AudioPlayerTests
{
    [Fact]
    public void PlayMessage_WithValidFile_InvokesAudioEngine()
    {
        var mockAudioEngine = new Mock<IAudioEngine>();
        var player = new AudioPlayer(mockAudioEngine.Object);

        player.PlayMessage("box_now.wav");

        mockAudioEngine.Verify(
            m => m.Play(It.Is<string>(s => s.EndsWith("box_now.wav"))),
            Times.Once);
    }

    [Fact]
    public async Task PlayMessage_WaitsForCompletion_BeforeNextMessage()
    {
        var mockAudioEngine = new Mock<IAudioEngine>();
        mockAudioEngine.Setup(m => m.IsPlaying()).Returns(true);
        var player = new AudioPlayer(mockAudioEngine.Object);

        player.PlayMessage("message1.wav");
        var canPlay = player.CanPlayMessage(); // Should be false

        Assert.False(canPlay);
    }
}
```

#### 2. Message Queue Tests
```csharp
// PitWall.Tests/Audio/MessageQueueTests.cs
public class MessageQueueTests
{
    [Fact]
    public void EnqueueMessage_DuplicateWithinCooldown_Ignored()
    {
        var queue = new MessageQueue(cooldownSeconds: 30);

        queue.Enqueue(new Message("Box now", Priority.Critical));
        queue.Enqueue(new Message("Box now", Priority.Critical)); // Duplicate

        Assert.Single(queue.GetPendingMessages());
    }

    [Fact]
    public void EnqueueMessage_HigherPriority_MovesToFront()
    {
        var queue = new MessageQueue();
        queue.Enqueue(new Message("Info msg", Priority.Info));
        queue.Enqueue(new Message("Critical msg", Priority.Critical));

        var next = queue.Dequeue();

        Assert.Equal("Critical msg", next.Text);
        Assert.Equal(Priority.Critical, next.Priority);
    }

    [Fact]
    public void EnqueueMessage_SameMessageAfterCooldown_Allowed()
    {
        var queue = new MessageQueue(cooldownSeconds: 1);

        queue.Enqueue(new Message("Box now", Priority.Critical));
        Thread.Sleep(1100); // Wait for cooldown
        queue.Enqueue(new Message("Box now", Priority.Critical));

        Assert.Equal(2, queue.TotalMessagesProcessed);
    }
}
```

#### 3. Integration Test
```csharp
// PitWall.Tests/Integration/AudioStrategyIntegrationTests.cs
public class AudioStrategyIntegrationTests
{
    [Fact]
    public async Task StrategyEngine_GeneratesRecommendation_TriggersAudio()
    {
        // Arrange
        var mockAudio = new Mock<IAudioEngine>();
        var audioPlayer = new AudioPlayer(mockAudio.Object);
        var engine = new StrategyEngine(audioPlayer);

        var telemetry = MockTelemetryBuilder.GT3()
            .WithFuelRemaining(9.0)
            .WithAverageFuelPerLap(5.0)
            .Build();

        // Act
        var recommendation = engine.GetRecommendation(telemetry);
        await audioPlayer.ProcessQueueAsync(); // Process audio queue

        // Assert
        mockAudio.Verify(
            m => m.Play(It.Is<string>(s => s.Contains("box"))),
            Times.Once);
    }
}
```

### Core Components

```csharp
// PitWall/Audio/IAudioEngine.cs
public interface IAudioEngine
{
    void Play(string filePath);
    bool IsPlaying();
    void Stop();
    void SetVolume(float volume); // 0.0 to 1.0
}

// PitWall/Audio/SimHubAudioEngine.cs
public class SimHubAudioEngine : IAudioEngine
{
    // Uses SimHub's PlaySound() method
}

// PitWall/Audio/AudioPlayer.cs
public class AudioPlayer
{
    private readonly IAudioEngine _engine;
    private readonly MessageQueue _queue;

    public void PlayMessage(string messageFile);
    public async Task ProcessQueueAsync();
}

// PitWall/Audio/MessageQueue.cs
public class MessageQueue
{
    private readonly PriorityQueue<Message> _queue;
    private readonly Dictionary<string, DateTime> _lastPlayed;

    public void Enqueue(Message message);
    public Message Dequeue();
    public bool IsDuplicate(Message message);
}

// PitWall/Models/Message.cs
public class Message
{
    public string Text { get; set; }
    public string AudioFile { get; set; }
    public Priority Priority { get; set; }
    public DateTime CreatedAt { get; set; }
}

public enum Priority
{
    Info = 0,
    Warning = 1,
    Critical = 2
}
```

### SimHub Integration Points

1. **Audio Playback**
   ```csharp
   // In PitWallPlugin.cs
   pluginManager.PlaySound(audioFilePath); // SimHub handles mixing
   ```

2. **Settings UI**
   ```csharp
   // In Init() method
   this.AddProperty("VolumeLevel", 0.8); // 0.0 to 1.0
   this.AddProperty("MessageCooldown", 30); // seconds
   this.AddProperty("EnableAudio", true); // bool toggle
   ```

3. **Audio File Location**
   - Store in `[SimHub]/PluginData/PitWall/Audio/`
   - Use relative paths in code
   - SimHub automatically finds plugin data folder

### Success Metrics

- ✅ Audio messages play without clicks/pops
- ✅ No duplicate messages within 30 seconds
- ✅ High priority messages interrupt low priority (tested)
- ✅ Volume control in SimHub settings works
- ✅ Queue processing <1ms per message
- ✅ Unit test coverage >85%

### Estimated Effort
**4-6 days**

- Day 1: Audio interfaces and mock implementations
- Day 2: Message queue with priority and cooldown
- Day 3: SimHub audio integration
- Day 4: Record/source audio samples (or use TTS temporarily)
- Day 5: Integration testing with real SimHub
- Day 6: Polish and edge case handling

### Dependencies
- Phase 1 complete (strategy engine working)
- Audio sample files (can use placeholder TTS initially)

### Audio Sample Checklist
```
Audio/
├── box_now.wav              # "Box this lap"
├── fuel_critical.wav        # "Fuel critical, 2 laps remaining"
├── fuel_ok.wav              # "Fuel looks good"
├── pit_window_open.wav      # "Pit window is open"
└── [more as needed]
```

---

## Phase 3: Tyre Degradation Tracking

### Goal
Monitor tyre performance degradation over a stint. Predict optimal pit window based on lap time delta.

### Acceptance Criteria
- [ ] Tracks lap times and calculates rolling average
- [ ] Detects lap time degradation trend (>0.5s slower than baseline)
- [ ] Accounts for traffic/incidents (outlier rejection)
- [ ] Recommends pit stop when tyres are "done" (>2s off pace)
- [ ] Works with limited telemetry (iRacing doesn't expose tyre temps)
- [ ] Generates "Tyres are going off" audio message

### Tests to Write First

#### 1. Lap Time Analysis Tests
```csharp
// PitWall.Tests/Strategy/TyreStrategyTests.cs
public class TyreStrategyTests
{
    [Fact]
    public void CalculateBaselinePace_FromFirst3Laps_ReturnsAverage()
    {
        var strategy = new TyreStrategy();
        strategy.RecordLap(120.5, isClear: true);
        strategy.RecordLap(119.8, isClear: true);
        strategy.RecordLap(120.2, isClear: true);

        var baseline = strategy.GetBaselinePace();

        Assert.InRange(baseline, 119.5, 120.5);
    }

    [Fact]
    public void RecordLap_WithTraffic_IsMarkedAsOutlier()
    {
        var strategy = new TyreStrategy();
        strategy.RecordLap(120.0, isClear: true);
        strategy.RecordLap(135.0, isClear: false); // Traffic
        strategy.RecordLap(120.1, isClear: true);

        var laps = strategy.GetCleanLaps();

        Assert.Equal(2, laps.Count); // Excludes traffic lap
    }

    [Theory]
    [InlineData(120.0, 122.5, 2.5)]  // Baseline: 120s, Current: 122.5s
    [InlineData(120.0, 119.5, -0.5)] // Improved pace
    public void CalculateDegradation_ReturnsDeltaFromBaseline(
        double baseline, double current, double expectedDelta)
    {
        var strategy = new TyreStrategy();
        var delta = strategy.CalculateDegradation(baseline, current);

        Assert.Equal(expectedDelta, delta, 0.1);
    }
}
```

#### 2. Outlier Detection Tests
```csharp
public class OutlierDetectionTests
{
    [Fact]
    public void IsOutlier_LapTime3SecondsSlower_ReturnsTrue()
    {
        var detector = new OutlierDetector();
        var recentLaps = new[] { 120.0, 120.5, 119.8, 120.2 };

        var isOutlier = detector.IsOutlier(124.0, recentLaps);

        Assert.True(isOutlier); // 4s slower = traffic/mistake
    }

    [Fact]
    public void IsOutlier_ConsistentDegradation_ReturnsFalse()
    {
        var detector = new OutlierDetector();
        var recentLaps = new[] { 120.0, 120.3, 120.6, 120.9 };

        var isOutlier = detector.IsOutlier(121.2, recentLaps);

        Assert.False(isOutlier); // Gradual degradation, not outlier
    }
}
```

#### 3. Pit Window Recommendation Tests
```csharp
public class PitWindowTests
{
    [Fact]
    public void ShouldPit_TyresDegraded2Seconds_ReturnsTrue()
    {
        var engine = new StrategyEngine();
        var telemetry = MockTelemetryBuilder.GT3()
            .WithBaselinePace(120.0)
            .WithRecentLaps(new[] { 121.8, 122.1, 122.3 }) // 2s+ slower
            .Build();

        var recommendation = engine.GetRecommendation(telemetry);

        Assert.True(recommendation.ShouldPit);
        Assert.Contains("tyres", recommendation.Message.ToLower());
    }

    [Fact]
    public void ShouldPit_CombinesFuelAndTyreStrategy_PrioritizesCritical()
    {
        var engine = new StrategyEngine();
        var telemetry = MockTelemetryBuilder.GT3()
            .WithFuelRemaining(8.0)           // Critical
            .WithAverageFuelPerLap(5.0)       // 1.6 laps left
            .WithTyreDegradation(1.5)         // Tyres OK
            .Build();

        var recommendation = engine.GetRecommendation(telemetry);

        Assert.Equal(Priority.Critical, recommendation.Priority);
        Assert.Contains("fuel", recommendation.Message.ToLower());
    }
}
```

### Core Components

```csharp
// PitWall/Strategy/TyreStrategy.cs
public class TyreStrategy
{
    private readonly List<LapData> _lapHistory = new();
    private double _baselinePace;

    public void RecordLap(double lapTime, bool isClear);
    public double GetBaselinePace();
    public double GetCurrentDegradation();
    public List<LapData> GetCleanLaps();
}

// PitWall/Strategy/OutlierDetector.cs
public class OutlierDetector
{
    public bool IsOutlier(double lapTime, IEnumerable<double> recentLaps);
    // Uses simple statistical method: >2 standard deviations
}

// PitWall/Models/LapData.cs
public class LapData
{
    public int LapNumber { get; set; }
    public double LapTime { get; set; }
    public bool IsClear { get; set; } // No traffic/yellows
    public double FuelUsed { get; set; }
    public DateTime Timestamp { get; set; }
}

// Update StrategyEngine.cs
public class StrategyEngine
{
    private readonly FuelStrategy _fuelStrategy;
    private readonly TyreStrategy _tyreStrategy; // NEW

    public Recommendation GetRecommendation(Telemetry telemetry)
    {
        // Combine fuel + tyre recommendations
        // Prioritize critical issues
    }
}
```

### SimHub Integration Points

1. **Lap Timing Properties**
   ```csharp
   "DataCorePlugin.GameData.LastLapTime"       // Last completed lap
   "DataCorePlugin.GameData.BestLapTime"       // Personal best this session
   "DataCorePlugin.GameData.IsLapValid"        // Track limits, no yellows
   ```

2. **Traffic Detection (Heuristics)**
   ```csharp
   // No direct "traffic" flag, so infer from:
   "DataCorePlugin.GameData.OpponentsNearCount" // Opponents within 50m
   "DataCorePlugin.GameData.Position"           // If position changed, might be traffic
   ```

3. **Tyre Temperature (if available)**
   ```csharp
   // ACC, RF2 expose this; iRacing does not
   "DataCorePlugin.GameData.TyreTemperatureFrontLeft"
   "DataCorePlugin.GameData.TyreWearFrontLeft" // 0-100%
   ```

### Success Metrics

- ✅ Baseline pace calculated from first 3 clean laps
- ✅ Outlier detection filters out traffic/mistakes (>90% accuracy in tests)
- ✅ Tyre degradation recommendation triggers at 2s+ delta
- ✅ Combined fuel+tyre strategy prioritizes correctly
- ✅ Audio messages: "Tyres going off, box when ready"
- ✅ Unit test coverage >85%

### Estimated Effort
**6-8 days**

- Day 1-2: Lap time tracking and baseline calculation
- Day 3: Outlier detection algorithm
- Day 4: Tyre degradation logic
- Day 5: Integration with StrategyEngine
- Day 6-7: Testing with real race data (ACC, iRacing)
- Day 8: Edge cases (rain, safety car, etc.)

### Dependencies
- Phase 1 complete (fuel strategy)
- Phase 2 complete (audio system)
- Test data from real races (can export from SimHub)

### Testing with Real Data

To validate with actual telemetry:
1. Run a 30-minute race in ACC
2. Export SimHub telemetry to JSON (use SimHub's logging)
3. Create integration test that replays telemetry
4. Verify recommendations match expected pit windows

```csharp
// PitWall.Tests/Integration/RealDataTests.cs
[Fact]
public void ReplayMonzaGT3Race_RecommendsPitAtLap18()
{
    var telemetryReplay = LoadTelemetryFile("monza_gt3_30min.json");
    var engine = new StrategyEngine();

    foreach (var lap in telemetryReplay)
    {
        var recommendation = engine.GetRecommendation(lap);
        if (lap.LapNumber == 18)
        {
            Assert.True(recommendation.ShouldPit);
        }
    }
}
```

---

## Phase 4: Multi-Class Race Awareness

### Goal
Detect opponent classes (LMP2 vs GT3) and adjust strategy for traffic management. Don't pit during LMP2 train.

### Acceptance Criteria
- [ ] Identifies opponent car classes from SimHub data
- [ ] Tracks class-based lap time deltas (LMP2 ~10s faster)
- [ ] Predicts when faster class will lap you
- [ ] Delays pit stop if LMP2 train approaching pit entry
- [ ] Generates "Wait for LMP2" audio message
- [ ] Works in single-class races (no false positives)

### Tests to Write First

```csharp
// PitWall.Tests/Strategy/MultiClassStrategyTests.cs
public class MultiClassStrategyTests
{
    [Fact]
    public void DetectCarClass_FromCarName_ReturnsCorrectClass()
    {
        var detector = new ClassDetector();

        Assert.Equal(CarClass.LMP2, detector.DetectClass("Oreca 07"));
        Assert.Equal(CarClass.GT3, detector.DetectClass("Porsche 911 GT3 R"));
    }

    [Fact]
    public void ShouldDelayPit_LMP2Within30Seconds_ReturnsTrue()
    {
        var strategy = new MultiClassStrategy();
        var opponents = new[]
        {
            new Opponent { Class = CarClass.LMP2, TimeBehind = 25.0 }
        };

        var shouldDelay = strategy.ShouldDelayPit(opponents);

        Assert.True(shouldDelay);
    }

    [Fact]
    public void ShouldDelayPit_SingleClassRace_ReturnsFalse()
    {
        var strategy = new MultiClassStrategy();
        var opponents = new[]
        {
            new Opponent { Class = CarClass.GT3, TimeBehind = 10.0 }
        };

        var shouldDelay = strategy.ShouldDelayPit(opponents);

        Assert.False(shouldDelay); // No faster class
    }
}
```

### Core Components

```csharp
// PitWall/Strategy/MultiClassStrategy.cs
public class MultiClassStrategy
{
    public bool ShouldDelayPit(IEnumerable<Opponent> opponents);
    public CarClass DetectPlayerClass(string carName);
    public TimeSpan EstimateTrafficWindow();
}

// PitWall/Models/Opponent.cs
public class Opponent
{
    public string Name { get; set; }
    public CarClass Class { get; set; }
    public double TimeBehind { get; set; } // Seconds behind player
    public double TimeAhead { get; set; }
    public int Position { get; set; }
}

public enum CarClass
{
    Unknown,
    GT3,
    GT4,
    LMP2,
    LMP3,
    Hypercars
}
```

### SimHub Integration Points

```csharp
// Opponent data (up to 60 opponents)
"Opponents.0.CarName"           // Car model name
"Opponents.0.GapSeconds"        // Time gap to player
"Opponents.0.IsInPitLane"       // In pit?
"Opponents.0.Position"          // Race position
```

### Success Metrics
- ✅ Class detection >95% accurate
- ✅ Pit delay prevents unsafe pit entries
- ✅ Audio: "Wait for LMP2 train"
- ✅ Works in single-class without false delays

### Estimated Effort
**4-5 days**

### Dependencies
- Phase 1-3 complete (strategy engine)

---

## Phase 5: Profile Learning & Historical Analysis

### Goal
Build a system that analyzes post-session telemetry to learn driver behavior and improve future recommendations.

### Acceptance Criteria
- [ ] Stores completed session data to SQLite database
- [ ] Calculates driver-specific fuel usage patterns
- [ ] Identifies driver's "panic brake" vs smooth driving laps
- [ ] Generates post-session report (JSON export)
- [ ] Loads historical profile on plugin init
- [ ] Uses profile to adjust fuel/tyre predictions
- [ ] Privacy: all data stored locally (no cloud)

### Tests to Write First

```csharp
// PitWall.Tests/Profiles/ProfileAnalyzerTests.cs
public class ProfileAnalyzerTests
{
    [Fact]
    public async Task AnalyzeSession_StoresFuelUsageProfile()
    {
        var db = new InMemoryDatabase();
        var analyzer = new ProfileAnalyzer(db);

        var session = MockSessionBuilder.GT3Race()
            .WithLaps(20)
            .WithAverageFuelPerLap(5.2)
            .Build();

        await analyzer.AnalyzeSessionAsync(session);

        var profile = await db.GetProfile("Player1", "Monza", "GT3");
        Assert.Equal(5.2, profile.AverageFuelPerLap, 0.1);
    }

    [Fact]
    public void IdentifyDrivingStyle_AggressiveBraking_ReturnsAggressive()
    {
        var analyzer = new ProfileAnalyzer();
        var laps = MockSessionBuilder.GT3Race()
            .WithHighBrakingVariance() // Panic braking
            .Build();

        var style = analyzer.IdentifyDrivingStyle(laps);

        Assert.Equal(DrivingStyle.Aggressive, style);
    }
}
```

### Core Components

```csharp
// PitWall/Profiles/ProfileAnalyzer.cs
public class ProfileAnalyzer
{
    private readonly IProfileDatabase _database;

    public async Task AnalyzeSessionAsync(SessionData session);
    public DrivingStyle IdentifyDrivingStyle(IEnumerable<LapData> laps);
    public DriverProfile LoadProfile(string driverName, string track, string car);
}

// PitWall/Profiles/DriverProfile.cs
public class DriverProfile
{
    public string DriverName { get; set; }
    public string TrackName { get; set; }
    public string CarName { get; set; }
    public double AverageFuelPerLap { get; set; }
    public double TypicalTyreDegradation { get; set; }
    public DrivingStyle Style { get; set; }
    public DateTime LastUpdated { get; set; }
}

// PitWall/Storage/IProfileDatabase.cs
public interface IProfileDatabase
{
    Task<DriverProfile> GetProfile(string driver, string track, string car);
    Task SaveProfile(DriverProfile profile);
    Task<List<SessionData>> GetRecentSessions(int count);
}
```

### SimHub Integration Points

```csharp
// Session metadata
"DataCorePlugin.GameData.TrackName"
"DataCorePlugin.GameData.CarName"
"DataCorePlugin.GameData.SessionType" // Practice, Qualify, Race
```

### Success Metrics
- ✅ SQLite database created in plugin folder
- ✅ Post-session analysis runs automatically
- ✅ Profile data improves fuel predictions by >10%
- ✅ Database size <100MB after 100 races

### Estimated Effort
**7-10 days**

- Day 1-2: SQLite integration
- Day 3-4: Profile analyzer logic
- Day 5-6: Historical data queries
- Day 7-8: Integration with strategy engine
- Day 9-10: Post-session reports and UI

### Dependencies
- Phase 1-3 complete

---

## Phase 6: Advanced Strategy - Undercut/Overcut

### Goal
Implement F1-style undercut/overcut detection. Recommend early pit stop to gain track position on fresher tyres.

### Acceptance Criteria
- [ ] Tracks gap to car ahead and behind
- [ ] Simulates pit stop time delta (e.g., 25 seconds)
- [ ] Predicts lap time gain on fresh tyres vs old
- [ ] Recommends undercut when gap allows position gain
- [ ] Generates "Box for undercut" audio message
- [ ] Works in both sprint and endurance races

### Tests to Write First

```csharp
// PitWall.Tests/Strategy/UndercutStrategyTests.cs
public class UndercutStrategyTests
{
    [Fact]
    public void CanUndercut_GapAllowsPositionGain_ReturnsTrue()
    {
        var strategy = new UndercutStrategy();
        var situation = new RaceSituation
        {
            GapToCarAhead = 5.0,        // 5 seconds ahead
            PitStopDuration = 25.0,     // 25s pit time
            FreshTyreAdvantage = 2.0    // 2s/lap faster on new tyres
        };

        var canUndercut = strategy.CanUndercut(situation);

        Assert.True(canUndercut); // Exit ahead after 3 laps
    }
}
```

### Estimated Effort
**5-7 days**

### Dependencies
- Phase 3 complete (tyre strategy)

---

## Phase 7: Weather & Track Condition Adaptation

### Goal
Detect changing conditions (rain, track temperature) and adjust strategy accordingly.

### Acceptance Criteria
- [ ] Detects rain from SimHub weather properties
- [ ] Recommends wet tyre change when rain detected
- [ ] Adjusts fuel usage for rain (typically higher)
- [ ] Tracks track temperature changes
- [ ] Generates "Rain in 3 minutes" audio message

### Estimated Effort
**4-6 days**

### Dependencies
- Phase 1-3 complete

---

## Phase 8: Damage & Repair Strategy

### Goal
Monitor car damage and recommend repairs during pit stops.

### Acceptance Criteria
- [ ] Reads damage telemetry (aero, suspension)
- [ ] Calculates lap time loss from damage
- [ ] Recommends repair if time loss > pit time cost
- [ ] Prioritizes critical repairs (suspension over aero)

### Estimated Effort
**3-5 days**

### Dependencies
- Phase 1-2 complete

---

## Phase 9: Voice Command Integration (Optional)

### Goal
Respond to driver voice commands like "Pit status" or "Fuel check".

### Acceptance Criteria
- [ ] Listens for wake word "Engineer"
- [ ] Recognizes commands: fuel, tyres, damage, gap
- [ ] Responds with audio message
- [ ] Low CPU impact (<2% added)

### Estimated Effort
**7-10 days** (complex, low priority)

### Dependencies
- Phase 1-3 complete
- Speech recognition library (Windows Speech API)

---

## Phase 10: UI Dashboard (Optional)

### Goal
Add a simple SimHub overlay showing strategy recommendations visually.

### Acceptance Criteria
- [ ] Overlay shows: pit countdown, fuel laps, tyre status
- [ ] Updates in real-time
- [ ] Minimal performance impact
- [ ] Customizable colors/position

### Estimated Effort
**5-7 days**

### Dependencies
- Phase 1-3 complete

---

## Long-Term Roadmap (Phase 11+)

### Additional Features to Consider

1. **Telemetry Export for Third-Party Analysis**
   - Export to CSV for use in data analysis tools
   - Integration with MoTeC/Motec i2

2. **Team Radio Integration**
   - Multi-driver session support
   - Crew chief coordination in endurance races

3. **AI-Powered Opponent Prediction**
   - Machine learning to predict opponent pit strategies
   - Track typical pit windows for known drivers

4. **Stint Planning UI**
   - Pre-race strategy planning tool
   - Calculate optimal stint lengths

5. **Integration with Racing Leagues**
   - API to submit strategy data to league organizers
   - Automated protest evidence collection

---

## Testing Strategy Overview

### Unit Tests (70% of tests)
- Pure logic, no SimHub dependencies
- Fast execution (<100ms per test)
- High coverage of strategy algorithms

### Integration Tests (20% of tests)
- Mock SimHub PluginManager
- Test data flow through plugin
- Audio playback verification

### End-to-End Tests (10% of tests)
- Replay real telemetry files
- Validate recommendations against known outcomes
- Performance benchmarks

### Test Data Management
```
PitWall.Tests/
└── TestData/
    ├── TelemetryReplays/
    │   ├── monza_gt3_30min.json
    │   ├── spa_multiclass_6hr.json
    │   └── iracing_nurb24.json
    └── MockAudioFiles/
        └── silent_1sec.wav
```

---

## Performance Budget

| Component | CPU Target | Memory Target |
|-----------|------------|---------------|
| Telemetry Processing | <1% | <10MB |
| Strategy Engine | <2% | <20MB |
| Audio Playback | <1% | <5MB |
| Database Queries | <0.5% | <15MB |
| **Total** | **<5%** | **<50MB** |

### Performance Testing
```csharp
// Run with every build
[Fact]
public void FullUpdateCycle_CompletesWithin10ms()
{
    var plugin = CreateProductionPlugin();
    var stopwatch = Stopwatch.StartNew();

    plugin.DataUpdate(mockManager, mockData);

    stopwatch.Stop();
    Assert.True(stopwatch.ElapsedMilliseconds < 10);
}
```

---

## CI/CD Pipeline

### GitHub Actions Workflow

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore --configuration Release

      - name: Test
        run: dotnet test --no-build --configuration Release --logger "trx;LogFileName=test-results.trx"

      - name: Performance Tests
        run: dotnet test --filter Category=Performance --no-build --configuration Release

      - name: Publish Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Test Results
          path: '**/test-results.trx'
          reporter: dotnet-trx

      - name: Package Plugin
        run: |
          mkdir release
          copy bin/Release/net48/PitWall.dll release/
          copy PluginManifest.json release/

      - name: Upload Artifact
        uses: actions/upload-artifact@v3
        with:
          name: PitWall-Plugin
          path: release/
```

---

## Developer Checklist

### Before Each Coding Session
- [ ] Pull latest changes: `git pull origin main`
- [ ] Run tests: `dotnet test`
- [ ] Check GitHub Actions status

### TDD Cycle (per feature)
1. [ ] Write failing test (Red)
2. [ ] Write minimal code to pass (Green)
3. [ ] Refactor for clarity (Refactor)
4. [ ] Run full test suite
5. [ ] Commit with clear message

### Before Each Commit
- [ ] All tests pass: `dotnet test`
- [ ] No compiler warnings: `dotnet build --warnaserror`
- [ ] Code formatted: Use VS Code auto-format
- [ ] Performance tests pass
- [ ] Update CHANGELOG.md if user-facing change

### Before Each Release
- [ ] Version bump in `PluginManifest.json`
- [ ] Update README.md with new features
- [ ] Tag release: `git tag v0.1.0`
- [ ] Test plugin load in SimHub
- [ ] Record demo video

---

## Resources for Python → C# Transition

### Learning Path
1. **C# Fundamentals** (2-3 days)
   - [Microsoft Learn: C# Tutorial](https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/)
   - Focus on: LINQ, async/await, interfaces

2. **xUnit Testing** (1 day)
   - [xUnit Documentation](https://xunit.net/)
   - [Moq Library](https://github.com/moq/moq4)

3. **SimHub Plugin Development** (2-3 days)
   - [SimHub Wiki](https://github.com/SHWotever/SimHub/wiki)
   - Study existing open-source plugins

### VS Code Extensions
- **C# Dev Kit** (Microsoft) - IntelliSense, debugging
- **GitHub Copilot** - AI pair programmer
- **.NET Core Test Explorer** - Run tests in sidebar
- **Coverage Gutters** - Show test coverage inline

### Keyboard Shortcuts
- `Ctrl+Shift+B` - Build solution
- `Ctrl+;` - Run tests under cursor
- `F12` - Go to definition
- `Shift+F12` - Find all references
- `Ctrl+.` - Quick fix / refactoring

---

## Estimated Total Timeline

| Phase | Duration | Cumulative |
|-------|----------|------------|
| Phase 0: Environment Setup | 3-5 days | 5 days |
| Phase 1: Fuel Strategy | 5-7 days | 12 days |
| Phase 2: Audio System | 4-6 days | 18 days |
| Phase 3: Tyre Strategy | 6-8 days | 26 days |
| Phase 4: Multi-Class | 4-5 days | 31 days |
| Phase 5: Profile Learning | 7-10 days | 41 days |
| Phase 6: Undercut Strategy | 5-7 days | 48 days |
| Phase 7: Weather Adaptation | 4-6 days | 54 days |
| Phase 8: Damage Strategy | 3-5 days | 59 days |

**MVP (Phases 0-3): ~4-6 weeks part-time**
**Full Feature Set (Phases 0-8): ~3-4 months part-time**

---

## Success Criteria for "Done"

### MVP Ready (Phase 3 Complete)
- ✅ Plugin loads in SimHub without errors
- ✅ Fuel and tyre strategy recommendations work
- ✅ Audio messages play at correct times
- ✅ <5% CPU usage during race
- ✅ Unit test coverage >80%
- ✅ Works in at least 2 sims (ACC, iRacing)

### Production Ready (Phase 8 Complete)
- ✅ All above, plus:
- ✅ Multi-class race support
- ✅ Profile learning improves accuracy
- ✅ Weather adaptation
- ✅ Damage detection
- ✅ Documentation for users
- ✅ Installation guide
- ✅ Video tutorial

### Community Release
- ✅ GitHub repository public
- ✅ MIT license applied
- ✅ README with screenshots
- ✅ Releases with versioned DLLs
- ✅ Issue tracker enabled
- ✅ Contributing guidelines

---

## Next Steps

1. **Immediate Actions**
   - [ ] Review this roadmap with project stakeholders
   - [ ] Set up development environment (Phase 0)
   - [ ] Create initial project structure
   - [ ] Write first test (PluginLifecycleTests)

2. **First Week Goals**
   - [ ] Complete Phase 0
   - [ ] Plugin loads in SimHub
   - [ ] CI/CD pipeline working
   - [ ] Mock telemetry framework in place

3. **First Month Goals**
   - [ ] Complete Phases 1-2
   - [ ] Fuel strategy working in real races
   - [ ] Audio messages playing correctly
   - [ ] Demo video recorded

---

## Questions for Consideration

1. **Audio Assets**: Will you record voice samples, use TTS, or hire voice talent?
2. **Test Data**: Do you have saved telemetry files from real races?
3. **Target Sims**: Priority order for sim support? (ACC, iRacing, RF2, R3E?)
4. **UI Preference**: Minimal overlay or detailed dashboard?
5. **Community**: Open beta testers available?

---

*This roadmap is a living document. Update as you complete phases and learn more about SimHub's capabilities.*

**Remember**: Ship small, test everything, iterate fast. Better to have a working fuel strategy than a half-built everything.
